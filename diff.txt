diff --git a/diff.txt b/diff.txt
index f029c5d..e69de29 100644
--- a/diff.txt
+++ b/diff.txt
@@ -1,685 +0,0 @@
-diff --git a/main.py b/main.py
-index dfc3c0a..c56d347 100644
---- a/main.py
-+++ b/main.py
-@@ -1,60 +1,72 @@
- import math
- 
--from matplotlib import pyplot
--from signal.signals import Impulse, Step, RealFormulaSignal, PluralFormulaSignal
--from signal.utils import Sampler, Recurrence
--from signal.tools import draw
-+from signal.signals import SamplerSignal, RealFormulaSignal, PluralFormulaSignal
- 
- 
--def formula1(n: int or float):
--    """
--    x(n) = e^((-0.2+0.7j)n)
--    x(n) = e^(-0.2n)*e^(0.7nj)
--    x(n) = e^(-0.2n)*(cos(0.7n)+j*sin(0.7n))
--    x(n) = e^(-0.2n)*cos(0.7n)+j*e^(-0.2n)*sin(0.7n)
--    """
--    exp = math.exp(-0.2 * n)
--    return exp * math.cos(0.7 * n), exp * math.sin(0.7 * n)
-+class X_S:
-+    def __init__(self, k, Ts, omega_s):
-+        self.k = k
-+        self.Ts = Ts
-+        self.omega_s = omega_s
- 
-+    def __call__(self, omega_div_pi):
-+        return 2e3 / (self.Ts * (1e6 + (omega_div_pi * math.pi - self.k * self.omega_s) ** 2))
- 
--def formula2(n: int):
--    n = n % 1
--    return n * 2 - 1
- 
-+class SA:
-+    def __init__(self, n, Ts, x_a_nTs):
-+        self.n = n
-+        self.Ts = Ts
-+        self.x_a_nTs = x_a_nTs
- 
--if __name__ == '__main__':
--    draw([Impulse(-10, 10, 2), Impulse(-10, 10, 2, delta_time=0.01, signal_type=float)])
--
--    draw([Step(-10, 10, 2), Step(-10, 10, 2, delta_time=0.01, signal_type=float)])
-+    def __call__(self, t):
-+        tmp = math.pi * (t / self.Ts - self.n)
-+        return self.x_a_nTs * math.sin(tmp) / tmp if tmp != 0 else self.x_a_nTs
- 
--    draw([RealFormulaSignal(lambda x: 0.75 ** x, -10, 10),
--          RealFormulaSignal(lambda x: 0.75 ** x, -10, 10,delta_time=0.01, signal_type=float)])
- 
--    PluralFormulaSignal(formula1, -10, 10).draw()
--
--    signal3 = RealFormulaSignal(formula2, 0, 2, delta_time=0.01, signal_type=float)
--    sample3 = Sampler(signal3, 32)
--    t1, x1 = zip(*list(signal3))
--    t2, x2 = zip(*list(sample3))
--    pyplot.plot(t1, x1)
--    pyplot.stem(t2, x2)
--    pyplot.xlabel("时间")
--    pyplot.ylabel("信号强度")
--    pyplot.show()
-+if __name__ == '__main__':
-+    sample_rate = 2000
-+    draw_rate = 0.1
-+    Ts = 1 / sample_rate
-+    omega_s = 2 * math.pi * sample_rate
-+    x_a_t = RealFormulaSignal(lambda t: math.exp(-1000 * abs(t)), start_time=-0.01, end_time=0.01, signal_type=float,
-+                              rate=10000)
-+    x_a_t.update(x_label=r'$x_a(t)$', t_label=r'$t$')
-+    x_a_t.draw()
-+    delta_t = RealFormulaSignal(lambda t: 1, start_time=x_a_t.start_time, end_time=x_a_t.end_time, rate=sample_rate)
-+    delta_t.update(x_label=r'$\delta(t)$', t_label=r'$t$')
-+    delta_t.draw()
- 
--    impulse = Impulse(-20, 20)
--    rec1 = Recurrence([1, 0.75, 0.125], [1, -1], impulse)
--    rec1.draw()
-+    sampler_signal_t = x_a_t * delta_t
- 
--    step = Step(-20, 20)
--    rec2 = Recurrence([1, 0.75, 0.125], [1, -1], step)
--    rec2.draw()
-+    sampler_signal_t.update(x_label=r'$x(n)$', t_label=r'$n$')
-+    sampler_signal_t.draw()
- 
--    rec3 = Recurrence([1, -0.8], [0.15],
--                      RealFormulaSignal(lambda x: 2 * math.sin(0.05 * math.pi * x), -20, 20))
--    rec3.draw()
-+    X_a_f = RealFormulaSignal(lambda omega_div_pi: 2e3 / (1e6 + (omega_div_pi * math.pi) ** 2), -5000, 5000,
-+                              signal_type=float, rate=draw_rate)
-+    X_a_f.update(x_label=r'$X_a(\Omega)$', t_label=r'$\Omega/\pi$')
-+    X_a_f.draw()
- 
--    signal4 = Step(-20, 20) - Step(-20, 20, switch_time=10)
--    signal4.draw()
--    rec4 = Recurrence([1, -0.9], [1], signal4)
--    rec4.draw()
-+    X_s_f = RealFormulaSignal(lambda x: 0, 0, 0, signal_type=float, rate=draw_rate)
-+    for k in range(-1, 2):
-+        tmp = RealFormulaSignal(X_S(k, Ts, omega_s),
-+                                -5000 + k * omega_s / math.pi, 5000 + k * omega_s / math.pi,
-+                                signal_type=float, rate=draw_rate)
-+        X_s_f = X_s_f + tmp
-+    X_s_f.update(x_label=r'$X_s(\Omega)$', t_label=r'$\Omega/\pi$')
-+    X_s_f.draw()
-+    x_a_t_ = RealFormulaSignal(lambda x: 0, start_time=x_a_t.start_time, end_time=x_a_t.end_time, signal_type=float,
-+                               rate=x_a_t.rate)
-+    sampler_signal_t.solve()
-+    n_min = int(min(sampler_signal_t.time_list) / Ts)
-+    n_max = int(max(sampler_signal_t.time_list) / Ts)
-+    for n in range(n_min, n_max + 1):
-+        sa = RealFormulaSignal(SA(n, Ts, sampler_signal_t[n * Ts]), start_time=x_a_t.start_time,
-+                               end_time=x_a_t.end_time, signal_type=float,
-+                               rate=x_a_t.rate)
-+        x_a_t_ = x_a_t_ + sa
-+    x_a_t_.update(x_label=r"$x'_a(t)$", t_label=r'$t$')
-+    x_a_t_.draw()
-+    deviation = x_a_t - x_a_t_
-+    deviation.update(x_label=r"$x_a(t)-x'_a(t)$", t_label=r't')
-+    deviation.draw()
-diff --git a/signal/__pycache__/base.cpython-39.pyc b/signal/__pycache__/base.cpython-39.pyc
-index a4d4110..4a0ba7c 100644
-Binary files a/signal/__pycache__/base.cpython-39.pyc and b/signal/__pycache__/base.cpython-39.pyc differ
-diff --git a/signal/__pycache__/signals.cpython-39.pyc b/signal/__pycache__/signals.cpython-39.pyc
-index a59f428..8b39ab7 100644
-Binary files a/signal/__pycache__/signals.cpython-39.pyc and b/signal/__pycache__/signals.cpython-39.pyc differ
-diff --git a/signal/__pycache__/tools.cpython-39.pyc b/signal/__pycache__/tools.cpython-39.pyc
-index 3a124ac..0d74e28 100644
-Binary files a/signal/__pycache__/tools.cpython-39.pyc and b/signal/__pycache__/tools.cpython-39.pyc differ
-diff --git a/signal/__pycache__/utils.cpython-39.pyc b/signal/__pycache__/utils.cpython-39.pyc
-index 664e830..8be47f4 100644
-Binary files a/signal/__pycache__/utils.cpython-39.pyc and b/signal/__pycache__/utils.cpython-39.pyc differ
-diff --git a/signal/base.py b/signal/base.py
-index 0e81937..e973645 100644
---- a/signal/base.py
-+++ b/signal/base.py
-@@ -1,5 +1,5 @@
- import abc
--from abc import ABC
-+import math
- 
- from matplotlib import pyplot
- from matplotlib.pyplot import MultipleLocator
-@@ -8,26 +8,39 @@ pyplot.rcParams['font.sans-serif'] = ['SimHei']
- pyplot.rcParams['axes.unicode_minus'] = False
- 
- 
--class Signal(metaclass=abc.ABCMeta):
--    """
--    信号基类
--    """
-+class Drawable(metaclass=abc.ABCMeta):
-+    def draw(self):
-+        raise NotImplementedError
-+
-+
-+class Signal(Drawable, metaclass=abc.ABCMeta):
-+    # 信号基类
- 
--    def __init__(self, start_time: float or int = 0, end_time: float or int = 0,
--                 delta_time: float or int = 1, signal_type=int):
-+    def __init__(self, start_time: float or int = 0, end_time: float or int = 0, rate: float or int = 1,
-+                 signal_type=int, zero_hold: bool = False, deviation: float = 1e-10, cache: bool = True):
-         """
-         :param start_time: 开始时间
-         :param end_time: 结束时间
--        :param delta_time: 最小时间片
-+        :param rate: 对于连续信号为绘制频率，只在迭代器上生效，对于离散信号为采样率，要求计算过程中采样率对齐
-         :param signal_type: 信号类型
-+        :param zero_hold: 0阶保持器
-+        :param deviation: 浮点数计算误差
-+        :param cache: 是否缓存结果
-         """
-+        self.zero_hold = zero_hold
-+        self.deviation = deviation
-         assert signal_type in [int, float]
-         self.signal_type = signal_type
--        self.delta_time = delta_time
-+        assert rate > 0
-+        self.delta_time = 1 / rate
-+        self.rate = rate
- 
-         assert start_time <= end_time
-         self.start_time = start_time
-         self.end_time = end_time
-+        self.cache = cache
-+        self.cache_list = []
-+        self.time_list = []
- 
-     def __iter__(self):
-         raise NotImplementedError
-@@ -36,7 +49,25 @@ class Signal(metaclass=abc.ABCMeta):
-         if time < self.start_time or time > self.end_time:
-             return 0
-         else:
--            return self.__kernel__(time)
-+            if self.signal_type is int:
-+                # 离散信号，采样率对齐，若未使用0阶保持器，采样点外一律为0
-+                mul = round((time - self.start_time) / self.delta_time)
-+                if self.zero_hold or math.isclose(time, self.start_time + self.delta_time * mul,
-+                                                  abs_tol=self.deviation):
-+                    # 使用0阶保持器或在浮点数计算误差范围之内
-+                    time = self.start_time + self.delta_time * mul
-+                else:
-+                    return 0
-+            if self.cache:
-+                if time in self.time_list:
-+                    ret = self.cache_list[self.time_list.index(time)]
-+                else:
-+                    ret = self.__kernel__(time)
-+                    self.cache_list.append(ret)
-+                    self.time_list.append(time)
-+            else:
-+                ret = self.__kernel__(time)
-+            return ret
- 
-     def __kernel__(self, time: float or int):
-         """
-@@ -55,6 +86,30 @@ class Signal(metaclass=abc.ABCMeta):
-         pyplot.ylabel(x_label)
-         pyplot.show()
- 
-+    def solve(self):
-+        return zip(*list(self))
-+
-+    def update(self, start_time: float or int = None, end_time: float or int = None, rate: float or int = None,
-+               signal_type=None, zero_hold: bool = None, deviation: float = None, cache: bool = None):
-+        if start_time is not None:
-+            self.start_time = start_time
-+        if end_time is not None:
-+            self.end_time = end_time
-+        assert self.start_time <= self.end_time
-+        if rate is not None:
-+            assert signal_type in [int, float]
-+            self.delta_time = 1 / rate
-+            self.rate = rate
-+        if signal_type is not None:
-+            assert signal_type in [int, float]
-+            self.signal_type = signal_type
-+        if zero_hold is not None:
-+            self.zero_hold = zero_hold
-+        if deviation is not None:
-+            self.deviation = deviation
-+        if cache is not None:
-+            self.cache = cache
-+
-     @staticmethod
-     def __plot__(t: list, x: list, x_label: str, t_label: str = "时间"):
-         pyplot.plot(t, x)
-@@ -64,9 +119,11 @@ class Signal(metaclass=abc.ABCMeta):
- 
- 
- class RealSignal(Signal, metaclass=abc.ABCMeta):
--    """
--    实数信号基类
--    """
-+    # 实数信号基类
-+    def __init__(self, *args, t_label="时间", x_label="信号强度", **kwargs):
-+        self.t_label = t_label
-+        self.x_label = x_label
-+        super(RealSignal, self).__init__(*args, **kwargs)
- 
-     def __add__(self, other):
-         assert issubclass(type(other), RealSignal)
-@@ -80,54 +137,45 @@ class RealSignal(Signal, metaclass=abc.ABCMeta):
-         assert issubclass(type(other), RealSignal)
-         return MultiRealSignal(self, other, "*")
- 
-+    def __pow__(self, other):
-+        # 卷积运算
-+        assert issubclass(type(other), RealSignal)
-+        return MultiRealSignal(self, other, "**")
-+
-     def __iter__(self) -> (float or int, float):
-         """
-         实数信号默认迭代器，产生从start time到end time以delta time为时间间隔的序列
-         :return: (时间，信号强度）
-         """
-+        cnt = 0
-         now = self.start_time
-         while now <= self.end_time:
-             yield now, self[now]
--            now += self.delta_time
-+            cnt += 1
-+            now = self.start_time + self.delta_time * cnt
-+
-+    def update(self, t_label=None, x_label=None, **kwargs):
-+        if t_label is not None:
-+            self.t_label = t_label
-+        if x_label is not None:
-+            self.x_label = x_label
-+        super(RealSignal, self).update(**kwargs)
- 
-     def draw(self):
--        t, y = zip(*list(self))
-+        t, y = self.solve()
-         if self.signal_type is int:
--            self.__stem__(t, y, "信号强度")
-+            self.__stem__(t, y, x_label=self.x_label, t_label=self.t_label)
-         else:
--            self.__plot__(t, y, "信号强度")
--
--
--class MultiRealSignal(RealSignal, metaclass=abc.ABCMeta):
--    """
--    复合实数信号基类
--    """
--
--    def __init__(self, signal1: RealSignal, signal2: RealSignal, multi_type: str, *args, **kwargs):
--        assert signal1.delta_time == signal1.delta_time and signal2.signal_type == signal2.signal_type
--        self.signal1 = signal1
--        self.signal2 = signal2
--        assert multi_type in ["+", "-", "*"]
--        self.multi_type = multi_type
--        super(MultiRealSignal, self).__init__(*args, start_time=min(signal1.start_time, signal2.start_time),
--                                              end_time=max(signal1.end_time, signal2.end_time),
--                                              delta_time=signal1.delta_time, **kwargs)
--
--    def __getitem__(self, time: float or int) -> float:
--        if time < self.start_time or time > self.end_time:
--            return 0
--        elif self.multi_type == '+':
--            return self.signal1[time] + self.signal2[time]
--        elif self.multi_type == '-':
--            return self.signal1[time] - self.signal2[time]
--        elif self.multi_type == '*':
--            return self.signal1[time] * self.signal2[time]
-+            self.__plot__(t, y, x_label=self.x_label, t_label=self.t_label)
- 
- 
- class PluralSignal(Signal, metaclass=abc.ABCMeta):
--    """
--    复数信号基类
--    """
-+    # 复数信号基类
-+    def __init__(self, *args, t_label="时间", x_label="实部信号强度", y_label="虚部信号强度", **kwargs):
-+        self.t_label = t_label
-+        self.x_label = x_label
-+        self.y_label = y_label
-+        super(PluralSignal, self).__init__(*args, **kwargs)
- 
-     def __add__(self, other):
-         assert issubclass(type(other), PluralSignal)
-@@ -141,16 +189,23 @@ class PluralSignal(Signal, metaclass=abc.ABCMeta):
-         assert issubclass(type(other), PluralSignal)
-         return MultiPluralSignal(self, other, "*")
- 
-+    def __pow__(self, other):
-+        # 卷积运算
-+        assert issubclass(type(other), PluralSignal)
-+        return MultiPluralSignal(self, other, "**")
-+
-     def __iter__(self) -> (float or int, float, float):
-         """
-         复数信号默认迭代器，产生从start time到end time以delta time为时间间隔的序列
-         :return: (时间，实部信号强度，复部信号强度）
-         """
-+        cnt = 0
-         now = self.start_time
-         while now <= self.end_time:
-             x, y = self[now]
-             yield now, x, y
--            now += self.delta_time
-+            cnt += 1
-+            now = self.start_time + self.delta_time * cnt
- 
-     @staticmethod
-     def __plot_3d__(t: list, x: list, y: list, x_label: str, y_label: str, t_label: str = "时间"):
-@@ -162,42 +217,126 @@ class PluralSignal(Signal, metaclass=abc.ABCMeta):
-         ax.set_zlabel(y_label)
-         pyplot.show()
- 
-+    def update(self, t_label=None, x_label=None, y_label=None, **kwargs):
-+        if t_label is not None:
-+            self.t_label = t_label
-+        if x_label is not None:
-+            self.x_label = x_label
-+        if y_label is not None:
-+            self.y_label = y_label
-+        super(PluralSignal, self).update(**kwargs)
-+
-     def draw(self):
--        t, x, y = zip(*list(self))
--        self.__plot_3d__(t, x, y, "实部信号强度", "虚部信号强度")
-+        t, x, y = self.solve()
-+        self.__plot_3d__(t, x, y, self.x_label, self.y_label, self.t_label)
-         if self.signal_type is int:
--            self.__stem__(t, x, "实部信号强度")
--            self.__stem__(t, y, "虚部信号强度")
-+            self.__stem__(t, x, self.x_label, self.t_label)
-+            self.__stem__(t, y, self.y_label, self.t_label)
-             pyplot.scatter(x, y)
-         else:
--            self.__plot__(t, x, "实部信号强度")
--            self.__plot__(t, y, "虚部信号强度")
--        self.__plot__(x, y, "虚部信号强度", "实部信号强度")
-+            self.__plot__(t, x, self.x_label, self.t_label)
-+            self.__plot__(t, y, self.y_label, self.t_label)
-+        self.__plot__(x, y, self.y_label, self.x_label)
-+
-+
-+class MultiRealSignal(RealSignal, metaclass=abc.ABCMeta):
-+    # 复合实数信号基类
-+
-+    def __init__(self, signal1: RealSignal, signal2: RealSignal, multi_type: str, *args, **kwargs):
-+        signal_type = int
-+        if signal1.signal_type is int and signal2.signal_type is int:
-+            assert signal1.delta_time == signal2.delta_time
-+            rate = signal1.rate
-+        elif signal1.signal_type is int:
-+            rate = signal1.rate
-+        else:
-+            if signal2.signal_type is float:
-+                signal_type = float
-+            rate = signal2.rate
-+        self.signal1 = signal1
-+        self.signal2 = signal2
-+        assert multi_type in ["+", "-", "*", "**"]
-+        self.multi_type = multi_type
-+        super(MultiRealSignal, self).__init__(*args, start_time=min(signal1.start_time, signal2.start_time),
-+                                              end_time=max(signal1.end_time, signal2.end_time),
-+                                              rate=rate, signal_type=signal_type, **kwargs)
-+
-+    def __getitem__(self, time: float or int) -> float:
-+        if time < self.start_time or time > self.end_time:
-+            return 0
-+        if self.cache and time in self.time_list:
-+            return self.cache_list[self.time_list.index(time)]
-+        ret = 0
-+        if self.multi_type == '+':
-+            ret = self.signal1[time] + self.signal2[time]
-+        elif self.multi_type == '-':
-+            ret = self.signal1[time] - self.signal2[time]
-+        elif self.multi_type == '*':
-+            ret = self.signal1[time] * self.signal2[time]
-+        elif self.multi_type == '**':
-+            cnt = 0
-+            delt = self.start_time
-+            while delt <= self.end_time:
-+                ret += self.signal1[delt] * self.signal2[time - delt]
-+                cnt += 1
-+                delt = self.start_time + self.delta_time * cnt
-+        if self.cache:
-+            self.time_list.append(time)
-+            self.cache_list.append(ret)
-+        return ret
- 
- 
- class MultiPluralSignal(RealSignal, metaclass=abc.ABCMeta):
--    """
--    复合复数信号基类
--    """
-+    # 复合复数信号基类
- 
-     def __init__(self, signal1: PluralSignal, signal2: PluralSignal, multi_type: str, *args, **kwargs):
--        assert signal1.delta_time == signal1.delta_time and signal2.signal_type == signal2.signal_type
-+        signal_type = int
-+        if signal1.signal_type is int and signal2.signal_type is int:
-+            assert signal1.delta_time == signal2.delta_time
-+            rate = signal1.rate
-+        elif signal1.signal_type is int:
-+            rate = signal1.rate
-+        else:
-+            if signal2.signal_type is float:
-+                signal_type = float
-+            rate = signal2.rate
-         self.signal1 = signal1
-         self.signal2 = signal2
--        assert multi_type in ["+", "-", "*"]
-+        assert multi_type in ["+", "-", "*", "**"]
-         self.multi_type = multi_type
-         super(MultiPluralSignal, self).__init__(*args, start_time=min(signal1.start_time, signal2.start_time),
-                                                 end_time=max(signal1.end_time, signal2.end_time),
--                                                delta_time=signal1.delta_time, **kwargs)
-+                                                rate=rate, signal_type=signal_type, **kwargs)
- 
-     def __getitem__(self, time: float or int) -> (float, float):
--        x1, y1 = self.signal1[time]
--        x2, y2 = self.signal2[time]
-         if time < self.start_time or time > self.end_time:
-             return 0, 0
--        elif self.multi_type == '+':
--            return x1 + x2, y1 + y2
-+        if self.cache and time in self.time_list:
-+            return self.cache_list[self.time_list.index(time)]
-+        x1, y1 = self.signal1[time]
-+        x2, y2 = self.signal2[time]
-+        ret1 = 0
-+        ret2 = 0
-+        if self.multi_type == '+':
-+            ret1 = x1 + x2
-+            ret2 = y1 + y2
-         elif self.multi_type == '-':
--            return x1 - x2, y1 - y2
-+            ret1 = x1 - x2
-+            ret2 = y1 - y2
-         elif self.multi_type == '*':
--            return x1 * x2 - y1 * y2, x1 * y2 + x2 * y1
-+            ret1 = x1 * x2 - y1 * y2
-+            ret2 = x1 * y2 + x2 * y1
-+        elif self.multi_type == '**':
-+            cnt = 0
-+            delt = self.start_time
-+            while delt <= self.end_time:
-+                x1, y1 = self.signal1[delt]
-+                x2, y2 = self.signal2[time - delt]
-+                ret1 += x1 * x2 - y1 * y2
-+                ret2 += x1 * y2 + x2 * y1
-+                cnt += 1
-+                delt = self.start_time + self.delta_time * cnt
-+        if self.cache:
-+            self.time_list.append(time)
-+            self.cache_list.append((ret1, ret2))
-+        return ret1, ret2
-diff --git a/signal/signals.py b/signal/signals.py
-index 5a02f7f..fb67924 100644
---- a/signal/signals.py
-+++ b/signal/signals.py
-@@ -1,3 +1,4 @@
-+import math
- from collections.abc import Callable
- from .base import RealSignal, PluralSignal
- 
-@@ -33,10 +34,7 @@ class Impulse(RealSignal):
-         self.switch_time = self.switch_time * self.delta_time + self.start_time
- 
-     def __kernel__(self, time: float or int) -> float:
--        """
--        浮点数比较存在精度误差，进行容错处理，误差<=delta time
--        """
--        return self.strength if 0 <= time - self.switch_time < self.delta_time else 0.0
-+        return self.strength if time == self.switch_time else 0
- 
- 
- class Step(RealSignal):
-@@ -87,14 +85,12 @@ class RealFormulaSignal(RealSignal):
-         self.formula = formula
-         super(RealFormulaSignal, self).__init__(*args, **kwargs)
- 
--    def __kernel__(self, time: float or int):
-+    def __kernel__(self, time: float or int) -> float:
-         return self.formula(time)
- 
- 
- class PluralFormulaSignal(PluralSignal):
--    """
--    使用复数公式或函数构建信号
--    """
-+    # 使用复数公式或函数构建信号
- 
-     def __init__(self, formula: Callable[float or int], *args, **kwargs):
-         """
-@@ -105,5 +101,19 @@ class PluralFormulaSignal(PluralSignal):
-         self.formula = formula
-         super(PluralFormulaSignal, self).__init__(*args, **kwargs)
- 
--    def __kernel__(self, time: float or int):
-+    def __kernel__(self, time: float or int) -> (float, float):
-         return self.formula(time)
-+
-+
-+class SamplerSignal(RealSignal):
-+    # 采样信号
-+
-+    def __init__(self, *args, **kwargs):
-+        """
-+        :param args: 其他基类参数
-+        :param kwargs: 其他基类参数
-+        """
-+        super(SamplerSignal, self).__init__(*args, **kwargs)
-+
-+    def __kernel__(self, time: float or int) -> float:
-+        return math.sin(time) / time
-diff --git a/signal/tools.py b/signal/tools.py
-index 3a4f7c4..95515ba 100644
---- a/signal/tools.py
-+++ b/signal/tools.py
-@@ -1,9 +1,18 @@
--from .base import Signal
-+import warnings
-+
-+from .base import Signal, Drawable
-+
-+
-+def __draw__(signal: Signal):
-+    if isinstance(signal, Drawable):
-+        signal.draw()
-+    else:
-+        warnings.warn("Error type.")
- 
- 
- def draw(signals: list or Signal):
-     if type(signals) is list:
-         for i in signals:
--            i.draw()
-+            __draw__(i)
-     else:
--        signals.draw()
-+        __draw__(signals)
-diff --git a/signal/utils.py b/signal/utils.py
-index 427bf14..6fcf0e7 100644
---- a/signal/utils.py
-+++ b/signal/utils.py
-@@ -1,10 +1,11 @@
--from .base import RealSignal
-+import math
-+
-+from .signals import PluralFormulaSignal
-+from .base import Signal, RealSignal, PluralSignal
- 
- 
- class Sampler(RealSignal):
--    """
--    连续信号采样器
--    """
-+    # 连续信号采样器
- 
-     def __init__(self, signal: RealSignal, sample_num: int, *args, **kwargs):
-         """
-@@ -16,9 +17,9 @@ class Sampler(RealSignal):
-         assert signal.signal_type is float
-         start_time = signal.start_time
-         end_time = signal.end_time
--        delta_time = (end_time - start_time) / (sample_num - 1)
-+        rate = (sample_num - 1) / (start_time - end_time)
-         self.signal = signal
--        super(Sampler, self).__init__(*args, start_time=start_time, end_time=end_time, delta_time=delta_time, **kwargs)
-+        super(Sampler, self).__init__(*args, start_time=start_time, end_time=end_time, rate=rate, **kwargs)
- 
-     def __kernel__(self, time: float or int) -> float:
-         return self.signal[time]
-@@ -32,26 +33,34 @@ class Recurrence(RealSignal):
-         :param input_signal: 输入信号
-         :param args: 其他基类参数
-         :param kwargs: 其他基类参数
--        cache: 求解结果缓存
--        times: 求解过的时间
-         """
--        self.cache = []
--        self.times = []
-         self.response_params = response_params
-         self.input_signal = input_signal
-         self.input_params = input_params
-         super(Recurrence, self).__init__(*args, start_time=input_signal.start_time, end_time=input_signal.end_time,
--                                         delta_time=input_signal.delta_time, **kwargs)
-+                                         rate=input_signal.rate, **kwargs)
- 
-     def __kernel__(self, time: float or int) -> float:
--        if time in self.times:
--            return self.cache[self.times.index(time)]
--        else:
--            result = 0
--            for i in range(len(self.input_params)):
--                result += self.input_signal[time - i * self.input_signal.delta_time] * self.input_params[i]
--            for i in range(1, len(self.response_params)):
--                result -= self[time - i * self.delta_time] * self.response_params[i]
--            self.times.append(time)
--            self.cache.append(result / self.response_params[0])
--            return self.cache[-1]
-+        result = 0
-+        for i in range(len(self.input_params)):
-+            result += self.input_signal[time - i * self.input_signal.delta_time] * self.input_params[i]
-+        for i in range(1, len(self.response_params)):
-+            result -= self[time - i * self.delta_time] * self.response_params[i]
-+        return result
-+
-+
-+class RealToPlural(PluralSignal):
-+    """
-+    将实数信号转换为复数信号
-+    """
-+
-+    def __init__(self, signal: RealSignal, **kwargs):
-+        """
-+        :param signal:
-+        """
-+        self.signal = signal
-+        super(RealToPlural, self).__init__(start_time=signal.start_time, end_time=signal.end_time,
-+                                           rate=signal.rate, signal_type=signal.signal_type, **kwargs)
-+
-+    def __kernel__(self, time: float or int) -> (float, float):
-+        return self.signal[time], 0
diff --git a/main.py b/main.py
index fd329a6..cf1beca 100644
--- a/main.py
+++ b/main.py
@@ -1,77 +1,35 @@
 import math
+import numpy
+from signal.signals import RealFormulaSignal, RealIterSignal
+from signal.utils import DFT
 
-from signal.signals import RealFormulaSignal
 
-
-class X_S:
-    def __init__(self, k, Ts, omega_s):
-        self.k = k
-        self.Ts = Ts
-        self.omega_s = omega_s
-
-    def __call__(self, omega_div_pi):
-        return 2e3 / (self.Ts * (1e6 + (omega_div_pi * math.pi - self.k * self.omega_s) ** 2))
-
-
-class SA:
-    def __init__(self, n, Ts, x_a_nTs):
-        self.n = n
-        self.Ts = Ts
-        self.x_a_nTs = x_a_nTs
-
-    def __call__(self, t):
-        tmp = math.pi * (t / self.Ts - self.n)
-        return self.x_a_nTs * math.sin(tmp) / tmp if tmp != 0 else self.x_a_nTs
+def formula(M):
+    xa = numpy.arange(0, math.floor(M / 2) + 1)
+    xb = numpy.arange(math.ceil(M / 2) - 1, -1, -1)
+    x = numpy.concatenate((xa, xb))
+    return x
 
 
 if __name__ == '__main__':
-
-    x_a_t = RealFormulaSignal(lambda t: math.exp(-1000 * abs(t)), start=-0.01, end=0.01, signal_type=float,
-                              rate=10000)
-    x_a_t.update(x_label=r'$x_a(t)$', t_label=r'$t$')
-    x_a_t.draw()
-
-    draw_rate = 0.1
-    X_a_f = RealFormulaSignal(lambda omega_div_pi: 2e3 / (1e6 + (omega_div_pi * math.pi) ** 2), -5000, 5000,
-                              signal_type=float, rate=draw_rate)
-    X_a_f.update(x_label=r'$X_a(j\Omega)$', t_label=r'$\Omega/\pi$')
-    X_a_f.draw()
-
-    print(X_a_f[2000])
-
-    for f_s in [1000,2000,4000]:
-        Ts = 1 / f_s
-        omega_s = 2 * math.pi * f_s
-        X_s_f = RealFormulaSignal(lambda x: 0, 0, 0, signal_type=float, rate=draw_rate)
-        for k in range(-1, 2):
-            tmp = RealFormulaSignal(X_S(k, Ts, omega_s),
-                                    -5000 - 2 * f_s, 5000 + 2 * f_s,
-                                    signal_type=float, rate=draw_rate)
-            X_s_f = X_s_f + tmp
-        X_s_f.update(x_label=r'$\hat{X_s}(j\Omega)$', t_label=r'$\Omega/\pi$')
-        X_s_f.draw()
-
-        delta_t = RealFormulaSignal(lambda t: 1, start=x_a_t.start, end=x_a_t.end, rate=f_s)
-        delta_t.update(x_label=r'$\delta(t)$', t_label=r'$t$')
-        delta_t.draw()
-
-        sampler_signal_t = x_a_t * delta_t
-        sampler_signal_t.update(x_label=r'$x(n)$', t_label=r'$n$')
-        sampler_signal_t.draw()
-
-        RealFormulaSignal(SA(0, Ts, 1), start=x_a_t.start, end=x_a_t.end, signal_type=float, rate=x_a_t.rate).draw()
-
-        start_n = int(sampler_signal_t.start / Ts)
-        end_n = int(sampler_signal_t.end / Ts)
-        x_a_t_ = RealFormulaSignal(lambda x: 0, start=x_a_t.start, end=x_a_t.end, signal_type=float,
-                                   rate=x_a_t.rate)
-        for n in range(start_n, end_n + 1):
-            sa = RealFormulaSignal(SA(n, Ts, sampler_signal_t[n * Ts]), start=x_a_t.start,
-                                   end=x_a_t.end, signal_type=float,
-                                   rate=x_a_t.rate)
-            x_a_t_ = x_a_t_ + sa
-        x_a_t_.update(x_label=r"$x'_a(t)$", t_label=r'$t$')
-        x_a_t_.draw()
-        deviation = x_a_t - x_a_t_
-        deviation.update(x_label=r"$x_a(t)-x'_a(t)$", t_label=r't')
-        deviation.draw()
+    N = 16
+    # R = RealIterSignal([1 for i in range(5)], start=0, end=4)
+    # d = DFT(R, length=N)
+    # d.draw()
+    # DFT(d, direction=1).draw()
+    # M = 27
+    # x = RealIterSignal(formula(M), 0, M)
+    # x.draw()
+    # d = DFT(x, length=N)
+    # d.draw()
+    # DFT(d, direction=1, length=N).draw()
+    x = [2, 3, 1, 4, 5]
+    h = [2, 1, 7, 4, 5, 7, 2, 3]
+    x_ = RealIterSignal(x, start=0, end=len(x) - 1)
+    h_ = RealIterSignal(h, start=0, end=len(h) - 1)
+    n = len(x) + len(h) - 1
+    d1 = DFT(x_, length=n)
+    d2 = DFT(h_, length=n)
+    y = DFT(d1 * d2, direction=1)
+    y.draw()
+    (x_ ** h_).draw()
diff --git a/signal/__pycache__/base.cpython-39.pyc b/signal/__pycache__/base.cpython-39.pyc
index 8e0fb45..837a1e1 100644
Binary files a/signal/__pycache__/base.cpython-39.pyc and b/signal/__pycache__/base.cpython-39.pyc differ
diff --git a/signal/__pycache__/signals.cpython-39.pyc b/signal/__pycache__/signals.cpython-39.pyc
index 4c1c48b..ce656c6 100644
Binary files a/signal/__pycache__/signals.cpython-39.pyc and b/signal/__pycache__/signals.cpython-39.pyc differ
diff --git a/signal/__pycache__/utils.cpython-39.pyc b/signal/__pycache__/utils.cpython-39.pyc
index 8be47f4..9003679 100644
Binary files a/signal/__pycache__/utils.cpython-39.pyc and b/signal/__pycache__/utils.cpython-39.pyc differ
diff --git a/signal/base.py b/signal/base.py
index 36f94f7..da6aba4 100644
--- a/signal/base.py
+++ b/signal/base.py
@@ -17,7 +17,8 @@ class Signal(Drawable, metaclass=abc.ABCMeta):
     # 信号基类
 
     def __init__(self, start: float or int = 0, end: float or int = 0, rate: float or int = 1,
-                 signal_type=int, zero_hold: bool = False, deviation: float = 1e-10, cache: bool = True):
+                 signal_type=int, cycle: bool = False, zero_hold: bool = False, deviation: float = 1e-10,
+                 cache: bool = True):
         """
         :param start: 开始时间
         :param end: 结束时间
@@ -31,6 +32,9 @@ class Signal(Drawable, metaclass=abc.ABCMeta):
         self.deviation = deviation
         assert signal_type in [int, float]
         self.signal_type = signal_type
+
+        self.cycle = cycle
+
         assert rate > 0
         self.delta = 1 / rate
         self.rate = rate
@@ -42,32 +46,38 @@ class Signal(Drawable, metaclass=abc.ABCMeta):
         self.cache_list = []
         self.var_list = []
 
+    def __len__(self) -> int:
+        return math.floor((self.end - self.start) / self.delta) + 1
+
     def __iter__(self):
         raise NotImplementedError
 
     def __getitem__(self, var: float or int):
-        if var < self.start or var > self.end:
-            return 0
-        else:
-            if self.signal_type is int:
-                # 离散信号，采样率对齐，若未使用0阶保持器，采样点外一律为0
-                mul = round((var - self.start) / self.delta)
-                if self.zero_hold or math.isclose(var, self.start + self.delta * mul,
-                                                  abs_tol=self.deviation):
-                    # 使用0阶保持器或在浮点数计算误差范围之内
-                    var = self.start + self.delta * mul
-                else:
-                    return 0
-            if self.cache:
-                if var in self.var_list:
-                    ret = self.cache_list[self.var_list.index(var)]
-                else:
-                    ret = self.__kernel__(var)
-                    self.cache_list.append(ret)
-                    self.var_list.append(var)
+        if self.cycle:
+            var = (var - self.start) % (self.end - self.start + self.delta) + self.start
+
+        if self.signal_type is int:
+            # 离散信号，采样率对齐，若未使用0阶保持器，采样点外一律为0
+            mul = round((var - self.start) / self.delta)
+            if self.zero_hold or math.isclose(var, self.start + self.delta * mul,
+                                              abs_tol=self.deviation):
+                # 使用0阶保持器或在浮点数计算误差范围之内
+                var = self.start + self.delta * mul
+            else:
+                return 0
+        if self.cache:
+            if var in self.var_list:
+                ret = self.cache_list[self.var_list.index(var)]
             else:
                 ret = self.__kernel__(var)
-            return ret
+                self.cache_list.append(ret)
+                self.var_list.append(var)
+        else:
+            ret = self.__kernel__(var)
+        return ret
+
+    def get_nth(self, n: int):
+        return self[self.start + self.delta * n]
 
     def __kernel__(self, var: float or int):
         """
@@ -89,8 +99,12 @@ class Signal(Drawable, metaclass=abc.ABCMeta):
     def solve(self):
         return zip(*list(self))
 
+    def clear(self):
+        self.cache_list.clear()
+        self.var_list.clear()
+
     def update(self, start: float or int = None, end: float or int = None, rate: float or int = None,
-               signal_type=None, zero_hold: bool = None, deviation: float = None, cache: bool = None):
+               signal_type=None, cycle=None, zero_hold: bool = None, deviation: float = None, cache: bool = None):
         if start is not None:
             self.start = start
         if end is not None:
@@ -103,6 +117,8 @@ class Signal(Drawable, metaclass=abc.ABCMeta):
         if signal_type is not None:
             assert signal_type in [int, float]
             self.signal_type = signal_type
+        if cycle is not None:
+            self.cycle = cycle
         if zero_hold is not None:
             self.zero_hold = zero_hold
         if deviation is not None:
@@ -154,6 +170,11 @@ class RealSignal(Signal, metaclass=abc.ABCMeta):
             cnt += 1
             now = self.start + self.delta * cnt
 
+    def __getitem__(self, var: float or int) -> float:
+        if not self.cycle and var < self.start or var > self.end:
+            return 0
+        return super(RealSignal, self).__getitem__(var)
+
     def update(self, t_label=None, x_label=None, **kwargs):
         if t_label is not None:
             self.t_label = t_label
@@ -207,6 +228,11 @@ class PluralSignal(Signal, metaclass=abc.ABCMeta):
             cnt += 1
             now = self.start + self.delta * cnt
 
+    def __getitem__(self, var: float or int) -> (float, float):
+        if not self.cycle and var < self.start or var > self.end:
+            return 0, 0
+        return super(PluralSignal, self).__getitem__(var)
+
     @staticmethod
     def __plot_3d__(t: list, x: list, y: list, x_label: str, y_label: str, t_label: str = "时间"):
         ax = pyplot.axes(projection="3d")
@@ -257,8 +283,8 @@ class MultiRealSignal(RealSignal, metaclass=abc.ABCMeta):
         self.signal2 = signal2
         assert multi_type in ["+", "-", "*", "**"]
         self.multi_type = multi_type
-        super(MultiRealSignal, self).__init__(*args, start=min(signal1.start, signal2.start),
-                                              end=max(signal1.end, signal2.end),
+        end = len(signal1) + len(signal2) - 2 if multi_type == "**" else max(signal1.end, signal2.end)
+        super(MultiRealSignal, self).__init__(*args, start=min(signal1.start, signal2.start), end=end,
                                               rate=rate, signal_type=signal_type, **kwargs)
 
     def __getitem__(self, var: float or int) -> float:
@@ -286,7 +312,7 @@ class MultiRealSignal(RealSignal, metaclass=abc.ABCMeta):
         return ret
 
 
-class MultiPluralSignal(RealSignal, metaclass=abc.ABCMeta):
+class MultiPluralSignal(PluralSignal, metaclass=abc.ABCMeta):
     # 复合复数信号基类
 
     def __init__(self, signal1: PluralSignal, signal2: PluralSignal, multi_type: str, *args, **kwargs):
@@ -304,13 +330,13 @@ class MultiPluralSignal(RealSignal, metaclass=abc.ABCMeta):
         self.signal2 = signal2
         assert multi_type in ["+", "-", "*", "**"]
         self.multi_type = multi_type
-        super(MultiPluralSignal, self).__init__(*args, start=min(signal1.start, signal2.start),
-                                                end=max(signal1.end, signal2.end),
+        end = len(signal1) + len(signal2) - 2 if multi_type == "**" else max(signal1.end, signal2.end)
+        super(MultiPluralSignal, self).__init__(*args, start=min(signal1.start, signal2.start), end=end,
                                                 rate=rate, signal_type=signal_type, **kwargs)
 
     def __getitem__(self, var: float or int) -> (float, float):
         if var < self.start or var > self.end:
-            return 0, 0
+            return 0.0, 0.0
         if self.cache and var in self.var_list:
             return self.cache_list[self.var_list.index(var)]
         x1, y1 = self.signal1[var]
diff --git a/signal/signals.py b/signal/signals.py
index 3de305b..55c4a49 100644
--- a/signal/signals.py
+++ b/signal/signals.py
@@ -105,6 +105,42 @@ class PluralFormulaSignal(PluralSignal):
         return self.formula(var)
 
 
+class RealIterSignal(RealSignal):
+    """
+    使用迭代列表构建信号
+    """
+
+    def __init__(self, iterable: list or tuple, *args, **kwargs):
+        """
+        :param iterable: 可迭代的数据列表
+        :param args: 其他基类参数
+        :param kwargs: 其他基类参数
+        """
+        self.iterable = iterable
+        super(RealIterSignal, self).__init__(*args, **kwargs)
+
+    def __kernel__(self, var: float or int) -> float:
+        var = int((var - self.start) / self.delta)
+        return self.iterable[var] if var < len(self.iterable) else 0
+
+
+class PluralIterSignal(PluralSignal):
+    # 使用复数迭代列表构建信号
+
+    def __init__(self, iterable: list or tuple, *args, **kwargs):
+        """
+        :param iterable: 可迭代的数据列表
+        :param args: 其他基类参数
+        :param kwargs: 其他基类参数
+        """
+        self.iterable = iterable
+        super(PluralIterSignal, self).__init__(*args, **kwargs)
+
+    def __kernel__(self, var: float or int) -> (float, float):
+        var = int((var - self.start) / self.delta)
+        return self.iterable[var] if var < len(self.iterable) else 0
+
+
 class SamplerSignal(RealSignal):
     # 采样信号
 
diff --git a/signal/utils.py b/signal/utils.py
index 5c05bd0..e718e68 100644
--- a/signal/utils.py
+++ b/signal/utils.py
@@ -1,7 +1,6 @@
 import math
 
-from .signals import PluralFormulaSignal
-from .base import Signal, RealSignal, PluralSignal
+from .base import Signal, RealSignal, PluralSignal, MultiPluralSignal
 
 
 class Sampler(RealSignal):
@@ -56,7 +55,7 @@ class RealToPlural(PluralSignal):
 
     def __init__(self, signal: RealSignal, **kwargs):
         """
-        :param signal:
+        :param signal: 待变换的信号
         """
         self.signal = signal
         super(RealToPlural, self).__init__(start=signal.start, end=signal.end,
@@ -64,3 +63,51 @@ class RealToPlural(PluralSignal):
 
     def __kernel__(self, var: float or int) -> (float, float):
         return self.signal[var], 0
+
+
+class FT(PluralSignal):
+    def __init__(self, signal: Signal, direction: int = -1, length: int = None, **kwargs):
+        """
+        傅立叶变换的实现，包含离散傅立叶变换和离散傅立叶逆变换
+        :param signal: 输入离散信号，包含实信号、复信号、DFT后的频谱密度
+        :param direction: 变换方向，-1为离散傅立叶变换，1为离散傅立叶逆变换
+        :param length: 信号长度，即N
+        :param kwargs: 其他基类参数
+        """
+        self.direction = direction
+        if self.direction == -1:
+            assert signal.signal_type is int
+            self.signal = RealToPlural(signal) if isinstance(signal, RealSignal) else signal
+        elif self.direction == 1:
+            assert isinstance(signal, FT) or isinstance(signal, MultiPluralSignal)
+            self.signal = signal
+        else:
+            raise ValueError("Error direction.")
+        end = self.signal.end if length is None else length - 1
+        self.length = len(signal) if length is None else length
+        super(FT, self).__init__(start=0, end=end, **kwargs)
+
+    def __kernel__(self, var: float or int) -> (float, float):
+        ret1 = ret2 = 0
+        for i in range(self.length):
+            x1, y1 = self.signal.get_nth(i)
+            x2 = math.cos(self.direction * 2 * math.pi * i * var / self.length)
+            y2 = math.sin(self.direction * 2 * math.pi * i * var / self.length)
+            ret1 += x1 * x2 - y1 * y2
+            ret2 += x1 * y2 + x2 * y1
+        ret1 = 0 if math.isclose(ret1, 0, abs_tol=self.deviation) else ret1
+        ret2 = 0 if math.isclose(ret2, 0, abs_tol=self.deviation) else ret2
+        if self.direction == 1:
+            ret1 /= self.length
+            ret2 /= self.length
+        return ret1, ret2
+
+
+class DFT(FT):
+    def __init__(self, signal: Signal, length: int = None, **kwargs):
+        super(DFT, self).__init__(signal, -1, length, **kwargs)
+
+
+class IDFT(FT):
+    def __init__(self, signal: Signal, length: int = None, **kwargs):
+        super(IDFT, self).__init__(signal, 1, length, **kwargs)
