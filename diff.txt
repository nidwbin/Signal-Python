diff --git a/main.py b/main.py
index dfc3c0a..c56d347 100644
--- a/main.py
+++ b/main.py
@@ -1,60 +1,72 @@
 import math
 
-from matplotlib import pyplot
-from signal.signals import Impulse, Step, RealFormulaSignal, PluralFormulaSignal
-from signal.utils import Sampler, Recurrence
-from signal.tools import draw
+from signal.signals import SamplerSignal, RealFormulaSignal, PluralFormulaSignal
 
 
-def formula1(n: int or float):
-    """
-    x(n) = e^((-0.2+0.7j)n)
-    x(n) = e^(-0.2n)*e^(0.7nj)
-    x(n) = e^(-0.2n)*(cos(0.7n)+j*sin(0.7n))
-    x(n) = e^(-0.2n)*cos(0.7n)+j*e^(-0.2n)*sin(0.7n)
-    """
-    exp = math.exp(-0.2 * n)
-    return exp * math.cos(0.7 * n), exp * math.sin(0.7 * n)
+class X_S:
+    def __init__(self, k, Ts, omega_s):
+        self.k = k
+        self.Ts = Ts
+        self.omega_s = omega_s
 
+    def __call__(self, omega_div_pi):
+        return 2e3 / (self.Ts * (1e6 + (omega_div_pi * math.pi - self.k * self.omega_s) ** 2))
 
-def formula2(n: int):
-    n = n % 1
-    return n * 2 - 1
 
+class SA:
+    def __init__(self, n, Ts, x_a_nTs):
+        self.n = n
+        self.Ts = Ts
+        self.x_a_nTs = x_a_nTs
 
-if __name__ == '__main__':
-    draw([Impulse(-10, 10, 2), Impulse(-10, 10, 2, delta_time=0.01, signal_type=float)])
-
-    draw([Step(-10, 10, 2), Step(-10, 10, 2, delta_time=0.01, signal_type=float)])
+    def __call__(self, t):
+        tmp = math.pi * (t / self.Ts - self.n)
+        return self.x_a_nTs * math.sin(tmp) / tmp if tmp != 0 else self.x_a_nTs
 
-    draw([RealFormulaSignal(lambda x: 0.75 ** x, -10, 10),
-          RealFormulaSignal(lambda x: 0.75 ** x, -10, 10,delta_time=0.01, signal_type=float)])
 
-    PluralFormulaSignal(formula1, -10, 10).draw()
-
-    signal3 = RealFormulaSignal(formula2, 0, 2, delta_time=0.01, signal_type=float)
-    sample3 = Sampler(signal3, 32)
-    t1, x1 = zip(*list(signal3))
-    t2, x2 = zip(*list(sample3))
-    pyplot.plot(t1, x1)
-    pyplot.stem(t2, x2)
-    pyplot.xlabel("时间")
-    pyplot.ylabel("信号强度")
-    pyplot.show()
+if __name__ == '__main__':
+    sample_rate = 2000
+    draw_rate = 0.1
+    Ts = 1 / sample_rate
+    omega_s = 2 * math.pi * sample_rate
+    x_a_t = RealFormulaSignal(lambda t: math.exp(-1000 * abs(t)), start_time=-0.01, end_time=0.01, signal_type=float,
+                              rate=10000)
+    x_a_t.update(x_label=r'$x_a(t)$', t_label=r'$t$')
+    x_a_t.draw()
+    delta_t = RealFormulaSignal(lambda t: 1, start_time=x_a_t.start_time, end_time=x_a_t.end_time, rate=sample_rate)
+    delta_t.update(x_label=r'$\delta(t)$', t_label=r'$t$')
+    delta_t.draw()
 
-    impulse = Impulse(-20, 20)
-    rec1 = Recurrence([1, 0.75, 0.125], [1, -1], impulse)
-    rec1.draw()
+    sampler_signal_t = x_a_t * delta_t
 
-    step = Step(-20, 20)
-    rec2 = Recurrence([1, 0.75, 0.125], [1, -1], step)
-    rec2.draw()
+    sampler_signal_t.update(x_label=r'$x(n)$', t_label=r'$n$')
+    sampler_signal_t.draw()
 
-    rec3 = Recurrence([1, -0.8], [0.15],
-                      RealFormulaSignal(lambda x: 2 * math.sin(0.05 * math.pi * x), -20, 20))
-    rec3.draw()
+    X_a_f = RealFormulaSignal(lambda omega_div_pi: 2e3 / (1e6 + (omega_div_pi * math.pi) ** 2), -5000, 5000,
+                              signal_type=float, rate=draw_rate)
+    X_a_f.update(x_label=r'$X_a(\Omega)$', t_label=r'$\Omega/\pi$')
+    X_a_f.draw()
 
-    signal4 = Step(-20, 20) - Step(-20, 20, switch_time=10)
-    signal4.draw()
-    rec4 = Recurrence([1, -0.9], [1], signal4)
-    rec4.draw()
+    X_s_f = RealFormulaSignal(lambda x: 0, 0, 0, signal_type=float, rate=draw_rate)
+    for k in range(-1, 2):
+        tmp = RealFormulaSignal(X_S(k, Ts, omega_s),
+                                -5000 + k * omega_s / math.pi, 5000 + k * omega_s / math.pi,
+                                signal_type=float, rate=draw_rate)
+        X_s_f = X_s_f + tmp
+    X_s_f.update(x_label=r'$X_s(\Omega)$', t_label=r'$\Omega/\pi$')
+    X_s_f.draw()
+    x_a_t_ = RealFormulaSignal(lambda x: 0, start_time=x_a_t.start_time, end_time=x_a_t.end_time, signal_type=float,
+                               rate=x_a_t.rate)
+    sampler_signal_t.solve()
+    n_min = int(min(sampler_signal_t.time_list) / Ts)
+    n_max = int(max(sampler_signal_t.time_list) / Ts)
+    for n in range(n_min, n_max + 1):
+        sa = RealFormulaSignal(SA(n, Ts, sampler_signal_t[n * Ts]), start_time=x_a_t.start_time,
+                               end_time=x_a_t.end_time, signal_type=float,
+                               rate=x_a_t.rate)
+        x_a_t_ = x_a_t_ + sa
+    x_a_t_.update(x_label=r"$x'_a(t)$", t_label=r'$t$')
+    x_a_t_.draw()
+    deviation = x_a_t - x_a_t_
+    deviation.update(x_label=r"$x_a(t)-x'_a(t)$", t_label=r't')
+    deviation.draw()
diff --git a/signal/__pycache__/base.cpython-39.pyc b/signal/__pycache__/base.cpython-39.pyc
index a4d4110..4a0ba7c 100644
Binary files a/signal/__pycache__/base.cpython-39.pyc and b/signal/__pycache__/base.cpython-39.pyc differ
diff --git a/signal/__pycache__/signals.cpython-39.pyc b/signal/__pycache__/signals.cpython-39.pyc
index a59f428..8b39ab7 100644
Binary files a/signal/__pycache__/signals.cpython-39.pyc and b/signal/__pycache__/signals.cpython-39.pyc differ
diff --git a/signal/__pycache__/tools.cpython-39.pyc b/signal/__pycache__/tools.cpython-39.pyc
index 3a124ac..0d74e28 100644
Binary files a/signal/__pycache__/tools.cpython-39.pyc and b/signal/__pycache__/tools.cpython-39.pyc differ
diff --git a/signal/__pycache__/utils.cpython-39.pyc b/signal/__pycache__/utils.cpython-39.pyc
index 664e830..8be47f4 100644
Binary files a/signal/__pycache__/utils.cpython-39.pyc and b/signal/__pycache__/utils.cpython-39.pyc differ
diff --git a/signal/base.py b/signal/base.py
index 0e81937..e973645 100644
--- a/signal/base.py
+++ b/signal/base.py
@@ -1,5 +1,5 @@
 import abc
-from abc import ABC
+import math
 
 from matplotlib import pyplot
 from matplotlib.pyplot import MultipleLocator
@@ -8,26 +8,39 @@ pyplot.rcParams['font.sans-serif'] = ['SimHei']
 pyplot.rcParams['axes.unicode_minus'] = False
 
 
-class Signal(metaclass=abc.ABCMeta):
-    """
-    信号基类
-    """
+class Drawable(metaclass=abc.ABCMeta):
+    def draw(self):
+        raise NotImplementedError
+
+
+class Signal(Drawable, metaclass=abc.ABCMeta):
+    # 信号基类
 
-    def __init__(self, start_time: float or int = 0, end_time: float or int = 0,
-                 delta_time: float or int = 1, signal_type=int):
+    def __init__(self, start_time: float or int = 0, end_time: float or int = 0, rate: float or int = 1,
+                 signal_type=int, zero_hold: bool = False, deviation: float = 1e-10, cache: bool = True):
         """
         :param start_time: 开始时间
         :param end_time: 结束时间
-        :param delta_time: 最小时间片
+        :param rate: 对于连续信号为绘制频率，只在迭代器上生效，对于离散信号为采样率，要求计算过程中采样率对齐
         :param signal_type: 信号类型
+        :param zero_hold: 0阶保持器
+        :param deviation: 浮点数计算误差
+        :param cache: 是否缓存结果
         """
+        self.zero_hold = zero_hold
+        self.deviation = deviation
         assert signal_type in [int, float]
         self.signal_type = signal_type
-        self.delta_time = delta_time
+        assert rate > 0
+        self.delta_time = 1 / rate
+        self.rate = rate
 
         assert start_time <= end_time
         self.start_time = start_time
         self.end_time = end_time
+        self.cache = cache
+        self.cache_list = []
+        self.time_list = []
 
     def __iter__(self):
         raise NotImplementedError
@@ -36,7 +49,25 @@ class Signal(metaclass=abc.ABCMeta):
         if time < self.start_time or time > self.end_time:
             return 0
         else:
-            return self.__kernel__(time)
+            if self.signal_type is int:
+                # 离散信号，采样率对齐，若未使用0阶保持器，采样点外一律为0
+                mul = round((time - self.start_time) / self.delta_time)
+                if self.zero_hold or math.isclose(time, self.start_time + self.delta_time * mul,
+                                                  abs_tol=self.deviation):
+                    # 使用0阶保持器或在浮点数计算误差范围之内
+                    time = self.start_time + self.delta_time * mul
+                else:
+                    return 0
+            if self.cache:
+                if time in self.time_list:
+                    ret = self.cache_list[self.time_list.index(time)]
+                else:
+                    ret = self.__kernel__(time)
+                    self.cache_list.append(ret)
+                    self.time_list.append(time)
+            else:
+                ret = self.__kernel__(time)
+            return ret
 
     def __kernel__(self, time: float or int):
         """
@@ -55,6 +86,30 @@ class Signal(metaclass=abc.ABCMeta):
         pyplot.ylabel(x_label)
         pyplot.show()
 
+    def solve(self):
+        return zip(*list(self))
+
+    def update(self, start_time: float or int = None, end_time: float or int = None, rate: float or int = None,
+               signal_type=None, zero_hold: bool = None, deviation: float = None, cache: bool = None):
+        if start_time is not None:
+            self.start_time = start_time
+        if end_time is not None:
+            self.end_time = end_time
+        assert self.start_time <= self.end_time
+        if rate is not None:
+            assert signal_type in [int, float]
+            self.delta_time = 1 / rate
+            self.rate = rate
+        if signal_type is not None:
+            assert signal_type in [int, float]
+            self.signal_type = signal_type
+        if zero_hold is not None:
+            self.zero_hold = zero_hold
+        if deviation is not None:
+            self.deviation = deviation
+        if cache is not None:
+            self.cache = cache
+
     @staticmethod
     def __plot__(t: list, x: list, x_label: str, t_label: str = "时间"):
         pyplot.plot(t, x)
@@ -64,9 +119,11 @@ class Signal(metaclass=abc.ABCMeta):
 
 
 class RealSignal(Signal, metaclass=abc.ABCMeta):
-    """
-    实数信号基类
-    """
+    # 实数信号基类
+    def __init__(self, *args, t_label="时间", x_label="信号强度", **kwargs):
+        self.t_label = t_label
+        self.x_label = x_label
+        super(RealSignal, self).__init__(*args, **kwargs)
 
     def __add__(self, other):
         assert issubclass(type(other), RealSignal)
@@ -80,54 +137,45 @@ class RealSignal(Signal, metaclass=abc.ABCMeta):
         assert issubclass(type(other), RealSignal)
         return MultiRealSignal(self, other, "*")
 
+    def __pow__(self, other):
+        # 卷积运算
+        assert issubclass(type(other), RealSignal)
+        return MultiRealSignal(self, other, "**")
+
     def __iter__(self) -> (float or int, float):
         """
         实数信号默认迭代器，产生从start time到end time以delta time为时间间隔的序列
         :return: (时间，信号强度）
         """
+        cnt = 0
         now = self.start_time
         while now <= self.end_time:
             yield now, self[now]
-            now += self.delta_time
+            cnt += 1
+            now = self.start_time + self.delta_time * cnt
+
+    def update(self, t_label=None, x_label=None, **kwargs):
+        if t_label is not None:
+            self.t_label = t_label
+        if x_label is not None:
+            self.x_label = x_label
+        super(RealSignal, self).update(**kwargs)
 
     def draw(self):
-        t, y = zip(*list(self))
+        t, y = self.solve()
         if self.signal_type is int:
-            self.__stem__(t, y, "信号强度")
+            self.__stem__(t, y, x_label=self.x_label, t_label=self.t_label)
         else:
-            self.__plot__(t, y, "信号强度")
-
-
-class MultiRealSignal(RealSignal, metaclass=abc.ABCMeta):
-    """
-    复合实数信号基类
-    """
-
-    def __init__(self, signal1: RealSignal, signal2: RealSignal, multi_type: str, *args, **kwargs):
-        assert signal1.delta_time == signal1.delta_time and signal2.signal_type == signal2.signal_type
-        self.signal1 = signal1
-        self.signal2 = signal2
-        assert multi_type in ["+", "-", "*"]
-        self.multi_type = multi_type
-        super(MultiRealSignal, self).__init__(*args, start_time=min(signal1.start_time, signal2.start_time),
-                                              end_time=max(signal1.end_time, signal2.end_time),
-                                              delta_time=signal1.delta_time, **kwargs)
-
-    def __getitem__(self, time: float or int) -> float:
-        if time < self.start_time or time > self.end_time:
-            return 0
-        elif self.multi_type == '+':
-            return self.signal1[time] + self.signal2[time]
-        elif self.multi_type == '-':
-            return self.signal1[time] - self.signal2[time]
-        elif self.multi_type == '*':
-            return self.signal1[time] * self.signal2[time]
+            self.__plot__(t, y, x_label=self.x_label, t_label=self.t_label)
 
 
 class PluralSignal(Signal, metaclass=abc.ABCMeta):
-    """
-    复数信号基类
-    """
+    # 复数信号基类
+    def __init__(self, *args, t_label="时间", x_label="实部信号强度", y_label="虚部信号强度", **kwargs):
+        self.t_label = t_label
+        self.x_label = x_label
+        self.y_label = y_label
+        super(PluralSignal, self).__init__(*args, **kwargs)
 
     def __add__(self, other):
         assert issubclass(type(other), PluralSignal)
@@ -141,16 +189,23 @@ class PluralSignal(Signal, metaclass=abc.ABCMeta):
         assert issubclass(type(other), PluralSignal)
         return MultiPluralSignal(self, other, "*")
 
+    def __pow__(self, other):
+        # 卷积运算
+        assert issubclass(type(other), PluralSignal)
+        return MultiPluralSignal(self, other, "**")
+
     def __iter__(self) -> (float or int, float, float):
         """
         复数信号默认迭代器，产生从start time到end time以delta time为时间间隔的序列
         :return: (时间，实部信号强度，复部信号强度）
         """
+        cnt = 0
         now = self.start_time
         while now <= self.end_time:
             x, y = self[now]
             yield now, x, y
-            now += self.delta_time
+            cnt += 1
+            now = self.start_time + self.delta_time * cnt
 
     @staticmethod
     def __plot_3d__(t: list, x: list, y: list, x_label: str, y_label: str, t_label: str = "时间"):
@@ -162,42 +217,126 @@ class PluralSignal(Signal, metaclass=abc.ABCMeta):
         ax.set_zlabel(y_label)
         pyplot.show()
 
+    def update(self, t_label=None, x_label=None, y_label=None, **kwargs):
+        if t_label is not None:
+            self.t_label = t_label
+        if x_label is not None:
+            self.x_label = x_label
+        if y_label is not None:
+            self.y_label = y_label
+        super(PluralSignal, self).update(**kwargs)
+
     def draw(self):
-        t, x, y = zip(*list(self))
-        self.__plot_3d__(t, x, y, "实部信号强度", "虚部信号强度")
+        t, x, y = self.solve()
+        self.__plot_3d__(t, x, y, self.x_label, self.y_label, self.t_label)
         if self.signal_type is int:
-            self.__stem__(t, x, "实部信号强度")
-            self.__stem__(t, y, "虚部信号强度")
+            self.__stem__(t, x, self.x_label, self.t_label)
+            self.__stem__(t, y, self.y_label, self.t_label)
             pyplot.scatter(x, y)
         else:
-            self.__plot__(t, x, "实部信号强度")
-            self.__plot__(t, y, "虚部信号强度")
-        self.__plot__(x, y, "虚部信号强度", "实部信号强度")
+            self.__plot__(t, x, self.x_label, self.t_label)
+            self.__plot__(t, y, self.y_label, self.t_label)
+        self.__plot__(x, y, self.y_label, self.x_label)
+
+
+class MultiRealSignal(RealSignal, metaclass=abc.ABCMeta):
+    # 复合实数信号基类
+
+    def __init__(self, signal1: RealSignal, signal2: RealSignal, multi_type: str, *args, **kwargs):
+        signal_type = int
+        if signal1.signal_type is int and signal2.signal_type is int:
+            assert signal1.delta_time == signal2.delta_time
+            rate = signal1.rate
+        elif signal1.signal_type is int:
+            rate = signal1.rate
+        else:
+            if signal2.signal_type is float:
+                signal_type = float
+            rate = signal2.rate
+        self.signal1 = signal1
+        self.signal2 = signal2
+        assert multi_type in ["+", "-", "*", "**"]
+        self.multi_type = multi_type
+        super(MultiRealSignal, self).__init__(*args, start_time=min(signal1.start_time, signal2.start_time),
+                                              end_time=max(signal1.end_time, signal2.end_time),
+                                              rate=rate, signal_type=signal_type, **kwargs)
+
+    def __getitem__(self, time: float or int) -> float:
+        if time < self.start_time or time > self.end_time:
+            return 0
+        if self.cache and time in self.time_list:
+            return self.cache_list[self.time_list.index(time)]
+        ret = 0
+        if self.multi_type == '+':
+            ret = self.signal1[time] + self.signal2[time]
+        elif self.multi_type == '-':
+            ret = self.signal1[time] - self.signal2[time]
+        elif self.multi_type == '*':
+            ret = self.signal1[time] * self.signal2[time]
+        elif self.multi_type == '**':
+            cnt = 0
+            delt = self.start_time
+            while delt <= self.end_time:
+                ret += self.signal1[delt] * self.signal2[time - delt]
+                cnt += 1
+                delt = self.start_time + self.delta_time * cnt
+        if self.cache:
+            self.time_list.append(time)
+            self.cache_list.append(ret)
+        return ret
 
 
 class MultiPluralSignal(RealSignal, metaclass=abc.ABCMeta):
-    """
-    复合复数信号基类
-    """
+    # 复合复数信号基类
 
     def __init__(self, signal1: PluralSignal, signal2: PluralSignal, multi_type: str, *args, **kwargs):
-        assert signal1.delta_time == signal1.delta_time and signal2.signal_type == signal2.signal_type
+        signal_type = int
+        if signal1.signal_type is int and signal2.signal_type is int:
+            assert signal1.delta_time == signal2.delta_time
+            rate = signal1.rate
+        elif signal1.signal_type is int:
+            rate = signal1.rate
+        else:
+            if signal2.signal_type is float:
+                signal_type = float
+            rate = signal2.rate
         self.signal1 = signal1
         self.signal2 = signal2
-        assert multi_type in ["+", "-", "*"]
+        assert multi_type in ["+", "-", "*", "**"]
         self.multi_type = multi_type
         super(MultiPluralSignal, self).__init__(*args, start_time=min(signal1.start_time, signal2.start_time),
                                                 end_time=max(signal1.end_time, signal2.end_time),
-                                                delta_time=signal1.delta_time, **kwargs)
+                                                rate=rate, signal_type=signal_type, **kwargs)
 
     def __getitem__(self, time: float or int) -> (float, float):
-        x1, y1 = self.signal1[time]
-        x2, y2 = self.signal2[time]
         if time < self.start_time or time > self.end_time:
             return 0, 0
-        elif self.multi_type == '+':
-            return x1 + x2, y1 + y2
+        if self.cache and time in self.time_list:
+            return self.cache_list[self.time_list.index(time)]
+        x1, y1 = self.signal1[time]
+        x2, y2 = self.signal2[time]
+        ret1 = 0
+        ret2 = 0
+        if self.multi_type == '+':
+            ret1 = x1 + x2
+            ret2 = y1 + y2
         elif self.multi_type == '-':
-            return x1 - x2, y1 - y2
+            ret1 = x1 - x2
+            ret2 = y1 - y2
         elif self.multi_type == '*':
-            return x1 * x2 - y1 * y2, x1 * y2 + x2 * y1
+            ret1 = x1 * x2 - y1 * y2
+            ret2 = x1 * y2 + x2 * y1
+        elif self.multi_type == '**':
+            cnt = 0
+            delt = self.start_time
+            while delt <= self.end_time:
+                x1, y1 = self.signal1[delt]
+                x2, y2 = self.signal2[time - delt]
+                ret1 += x1 * x2 - y1 * y2
+                ret2 += x1 * y2 + x2 * y1
+                cnt += 1
+                delt = self.start_time + self.delta_time * cnt
+        if self.cache:
+            self.time_list.append(time)
+            self.cache_list.append((ret1, ret2))
+        return ret1, ret2
diff --git a/signal/signals.py b/signal/signals.py
index 5a02f7f..fb67924 100644
--- a/signal/signals.py
+++ b/signal/signals.py
@@ -1,3 +1,4 @@
+import math
 from collections.abc import Callable
 from .base import RealSignal, PluralSignal
 
@@ -33,10 +34,7 @@ class Impulse(RealSignal):
         self.switch_time = self.switch_time * self.delta_time + self.start_time
 
     def __kernel__(self, time: float or int) -> float:
-        """
-        浮点数比较存在精度误差，进行容错处理，误差<=delta time
-        """
-        return self.strength if 0 <= time - self.switch_time < self.delta_time else 0.0
+        return self.strength if time == self.switch_time else 0
 
 
 class Step(RealSignal):
@@ -87,14 +85,12 @@ class RealFormulaSignal(RealSignal):
         self.formula = formula
         super(RealFormulaSignal, self).__init__(*args, **kwargs)
 
-    def __kernel__(self, time: float or int):
+    def __kernel__(self, time: float or int) -> float:
         return self.formula(time)
 
 
 class PluralFormulaSignal(PluralSignal):
-    """
-    使用复数公式或函数构建信号
-    """
+    # 使用复数公式或函数构建信号
 
     def __init__(self, formula: Callable[float or int], *args, **kwargs):
         """
@@ -105,5 +101,19 @@ class PluralFormulaSignal(PluralSignal):
         self.formula = formula
         super(PluralFormulaSignal, self).__init__(*args, **kwargs)
 
-    def __kernel__(self, time: float or int):
+    def __kernel__(self, time: float or int) -> (float, float):
         return self.formula(time)
+
+
+class SamplerSignal(RealSignal):
+    # 采样信号
+
+    def __init__(self, *args, **kwargs):
+        """
+        :param args: 其他基类参数
+        :param kwargs: 其他基类参数
+        """
+        super(SamplerSignal, self).__init__(*args, **kwargs)
+
+    def __kernel__(self, time: float or int) -> float:
+        return math.sin(time) / time
diff --git a/signal/tools.py b/signal/tools.py
index 3a4f7c4..95515ba 100644
--- a/signal/tools.py
+++ b/signal/tools.py
@@ -1,9 +1,18 @@
-from .base import Signal
+import warnings
+
+from .base import Signal, Drawable
+
+
+def __draw__(signal: Signal):
+    if isinstance(signal, Drawable):
+        signal.draw()
+    else:
+        warnings.warn("Error type.")
 
 
 def draw(signals: list or Signal):
     if type(signals) is list:
         for i in signals:
-            i.draw()
+            __draw__(i)
     else:
-        signals.draw()
+        __draw__(signals)
diff --git a/signal/utils.py b/signal/utils.py
index 427bf14..6fcf0e7 100644
--- a/signal/utils.py
+++ b/signal/utils.py
@@ -1,10 +1,11 @@
-from .base import RealSignal
+import math
+
+from .signals import PluralFormulaSignal
+from .base import Signal, RealSignal, PluralSignal
 
 
 class Sampler(RealSignal):
-    """
-    连续信号采样器
-    """
+    # 连续信号采样器
 
     def __init__(self, signal: RealSignal, sample_num: int, *args, **kwargs):
         """
@@ -16,9 +17,9 @@ class Sampler(RealSignal):
         assert signal.signal_type is float
         start_time = signal.start_time
         end_time = signal.end_time
-        delta_time = (end_time - start_time) / (sample_num - 1)
+        rate = (sample_num - 1) / (start_time - end_time)
         self.signal = signal
-        super(Sampler, self).__init__(*args, start_time=start_time, end_time=end_time, delta_time=delta_time, **kwargs)
+        super(Sampler, self).__init__(*args, start_time=start_time, end_time=end_time, rate=rate, **kwargs)
 
     def __kernel__(self, time: float or int) -> float:
         return self.signal[time]
@@ -32,26 +33,34 @@ class Recurrence(RealSignal):
         :param input_signal: 输入信号
         :param args: 其他基类参数
         :param kwargs: 其他基类参数
-        cache: 求解结果缓存
-        times: 求解过的时间
         """
-        self.cache = []
-        self.times = []
         self.response_params = response_params
         self.input_signal = input_signal
         self.input_params = input_params
         super(Recurrence, self).__init__(*args, start_time=input_signal.start_time, end_time=input_signal.end_time,
-                                         delta_time=input_signal.delta_time, **kwargs)
+                                         rate=input_signal.rate, **kwargs)
 
     def __kernel__(self, time: float or int) -> float:
-        if time in self.times:
-            return self.cache[self.times.index(time)]
-        else:
-            result = 0
-            for i in range(len(self.input_params)):
-                result += self.input_signal[time - i * self.input_signal.delta_time] * self.input_params[i]
-            for i in range(1, len(self.response_params)):
-                result -= self[time - i * self.delta_time] * self.response_params[i]
-            self.times.append(time)
-            self.cache.append(result / self.response_params[0])
-            return self.cache[-1]
+        result = 0
+        for i in range(len(self.input_params)):
+            result += self.input_signal[time - i * self.input_signal.delta_time] * self.input_params[i]
+        for i in range(1, len(self.response_params)):
+            result -= self[time - i * self.delta_time] * self.response_params[i]
+        return result
+
+
+class RealToPlural(PluralSignal):
+    """
+    将实数信号转换为复数信号
+    """
+
+    def __init__(self, signal: RealSignal, **kwargs):
+        """
+        :param signal:
+        """
+        self.signal = signal
+        super(RealToPlural, self).__init__(start_time=signal.start_time, end_time=signal.end_time,
+                                           rate=signal.rate, signal_type=signal.signal_type, **kwargs)
+
+    def __kernel__(self, time: float or int) -> (float, float):
+        return self.signal[time], 0
